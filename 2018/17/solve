#!/usr/bin/env python3
import re
import typing as T
from collections import defaultdict
from pathlib import Path

from PIL import Image

WELL_X = 500
WELL_Y = 0

AIR = "."
CLAY = "#"
WELL = "+"
STILL_WATER = "~"
RUNNING_WATER = "|"


def parse_chunk(text: str) -> T.List[int]:
    num = list(map(int, re.findall(r"\d+", text)))
    if len(num) == 2:
        return list(range(num[0], num[1] + 1))
    elif len(num) == 1:
        return [num[0]]
    raise AssertionError


class World:
    def __init__(self, text: str) -> None:
        self._cells = defaultdict(lambda: AIR)
        for line in text.split("\n"):
            if not line:
                continue
            chunk_x, chunk_y = sorted(line.split())
            xs = parse_chunk(chunk_x)
            ys = parse_chunk(chunk_y)
            for x in xs:
                for y in ys:
                    self._cells[x, y] = CLAY

        self.x1 = min(key[0] for key in self._cells.keys()) - 1
        self.x2 = max(key[0] for key in self._cells.keys()) + 1
        self.y1 = min(key[1] for key in self._cells.keys())
        self.y2 = max(key[1] for key in self._cells.keys())
        self.w = self.x2 + 1 - self.x1
        self.h = self.y2 + 1 - self.y1
        self._cells[WELL_X, WELL_Y] = WELL

        self.scanline = WELL_Y

    def __getitem__(self, pos: T.Tuple[int, int]) -> str:
        return self._cells[pos]

    def __setitem__(self, pos: T.Tuple[int, int], value: str) -> None:
        x, y = pos
        self._cells[pos] = value

    def turn(self) -> bool:
        y = self.scanline

        ret = False
        for x in range(self.x1, self.x2 + 1):
            if self[x, y] == WELL:
                self[x, y + 1] = RUNNING_WATER
                self.scanline += 1
                return True

            if self[x, y] != RUNNING_WATER:
                continue

            if self[x, y + 1] != AIR and self[x, y + 1] in {STILL_WATER, CLAY}:
                if self[x - 1, y] == AIR:
                    self[x - 1, y] = RUNNING_WATER
                    ret = True
                if self[x + 1, y] == AIR:
                    self[x + 1, y] = RUNNING_WATER
                    ret = True
        if ret:
            return ret

        ret = False
        for x in range(self.x1, self.x2 + 1):
            if self[x, y] != RUNNING_WATER:
                continue
            if self[x, y + 1] == AIR:
                continue

            if self[x - 1, y] == CLAY:
                x2 = x
                while self[x2 + 1, y] == RUNNING_WATER:
                    x2 += 1
                if self[x2 + 1, y] == CLAY:
                    for x in range(x, x2 + 1):
                        self[x, y] = STILL_WATER
                    ret = True
        if ret:
            self.scanline -= 1
            return ret

        ret = False
        for x in range(self.x1, self.x2 + 1):
            if self[x, y] != RUNNING_WATER:
                continue
            if self[x, y + 1] == AIR:
                self[x, y + 1] = RUNNING_WATER
                ret = True
        self.scanline += 1
        if self.scanline > self.y2:
            return False
        return ret

    def save_image(self, path: Path) -> None:
        img = Image.new("RGB", (self.w, self.h), "black")
        pixels = img.load()
        colors: T.Dict[str, T.Tuple[int, int, int]] = {
            AIR: (0, 0, 0),
            RUNNING_WATER: (0, 0, 255),
            STILL_WATER: (0, 0, 128),
            WELL: (255, 255, 0),
            CLAY: (256, 200, 0),
        }
        for x, y in self._cells.keys():
            if self.x1 <= x <= self.x2 and self.y1 <= y <= self.y2:
                pixels[x - self.x1, y - self.y1] = colors[self[x, y]]
        img.save(str(path), format="png")


def part1(world: World) -> int:
    total = 0
    for pos, cell in world._cells.items():
        x, y = pos
        if y < world.y1 or y > world.y2:
            continue
        if cell in {STILL_WATER, RUNNING_WATER}:
            total += 1
    return total


def part2(world: World) -> int:
    total = 0
    for pos, cell in world._cells.items():
        x, y = pos
        if y < world.y1 or y > world.y2:
            continue
        if cell == STILL_WATER:
            total += 1
    return total


def main() -> None:
    text = Path(__file__).with_name("input.txt").read_text()
    world = World(text)

    while True:
        if not world.turn():
            break
    world.save_image(Path(__file__).with_name(f"image.png"))

    print(part1(world))
    print(part2(world))


if __name__ == "__main__":
    main()
